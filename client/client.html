<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Kein Client</title>
<style>
:root
{
--player: magenta;
--river-field: blue;
--start-field: yellow;
--check-point: cyan;
--hole: black;
--eagle-field: brown;
--wall: #ff0000;
--lembas-field: #80ff00;
--eagle-field: #804000;
--eye: orange;
}

body
{
    font-family: sans-serif;
    margin: 10px;
    background: #222;
}

#legend,
.box,
#pause,
#exit,
#reconnect,
#connectButton
#joinButton,
#confirm_character_choice,
#confirm_card_choice,
#readyButton
{
    clear:left;
    float:left;
}

#left,
#right
{
    float:left;
}

#legend,
.box
{
    background: #444;
    padding: 10px;
    font-weight: bold;
    width: 200px;
    box-sizing: border-box;
    border-radius: 5px;
    color: #fff;
    margin: 0 10px 10px 0
}

.box select,
.box input
{
    width: 100%;
    line-height: 30px;
    height: 30px;
    box-sizing: border-box;
    border: none;
    margin: 10px 0 10px 0;
    border-radius: 5px;
}

#pause,
#exit,
#reconnect,
#connectButton,
#joinButton,
#confirm_character_choice,
#confirm_card_choice,
#readyButton
{
    color: #000;
    background: #fff;
    border-radius: 5px;
    line-height:30px;
    text-align:center;
    width: 100%;
    margin: 0 10px 10px 0;
    cursor: pointer;
}

#pause:hover,
#readyButton:hover,
#exit:hover,
#reconnect:hover
{
    background: #ccc;
}

#confirm_character_choice,
#confirm_card_choice
{
    width: 320px;
}

#pause,
#exit,
#reconnect,
#readyButton
{
    width: 200px;
}

#connectButton,
#joinButton
{
    margin: 0 10px 0 0;
}

.player
{
    color: var(--player)
}

.start-field
{
    color: var(--start-field);
}

.wall
{
    color: var(--wall);
}

.eagle-field
{
    color: var(--eagle-field);
}

.lembas-field
{
    color: var(--lembas-field);
}

.check-point
{
    color: var(--check-point)
}

.eye
{
    color: var(--eye);
}

.hole
{
    color: var(--hole)
}

.river-field
{
    color: var(--river-field);
}

.character
{
    width: 155px;
    height: 155px;
    line-height: 155px;
    text-align: center;
    background: grey;
    margin: 0 10px 10px 0;
    border-radius: 10px;
    float: left;
    background: #808000;
}

#character .character.active
{
    background: #008000
}

.card
{
    width: 100px;
    height: 100px;
    border-radius: 10px;
    background: grey;
    margin: 0 10px 10px 0;
    float: left;
    text-align: center;
    line-height: 100px;
}
.card:nth-child(3n + 1)
{
    clear:left;
}

#cards .card
{
    background: #808000;
}

#cards_choice .card
{
    background: #008000;
}

#roundCounter
{
    float: right;
}

.participant
{
    font-weight: normal;
    padding: 0 0 0 10px;
}

.ready
{
    color: lime;
}

</style>
</head>
<body>

    <div id="left">
    
        <div class="box">
        
            <label for="serverIpInput">Enter server IP</label>
            
            <input value="localhost" name="serverIpInput" id="serverIpInput" type="text">
            
            <label for="serverPortInput">Enter server port</label>
            
            <input value="8080" name="serverPortInput" id="serverPortInput" type="text">
            <div id="connectButton">CONNECT</div>
        
        </div>
        
        <div class="box">
        
            <label for="playerNameInput">Enter your name</label>
            
            <input value="Nudel" name="playerNameInput" id="playerNameInput" type="text">

            <label for="roleDropdown">Choose a role</label>
            
            <select name="roleDropdown"  id="roleDropdown">
                <option value="PLAYER">PLAYER</option>
                <option value="SPECTATOR">SPECTATOR</option>
            </select>

            <div id="joinButton">JOIN</div>
        
        </div>
        
        <div id="readyButton">READY</div>
        
        <div id="pause">PAUSE</div>
        
        <div id="exit">EXIT</div>
        
        <div id="reconnect">RECONNECT</div>
        
        <div id="rounds" class="box">
            ROUND <div id="roundCounter"></div>
        </div>
        
        <div id="participants" class="box">
            PARTICIPANTS<br>
            <br>
            <br>
            PLAYER<br>
            <br>
            <div id="playersList"></div>
            <br>
            SPECTATOR<br>
            <br>
            <div id="spectatorsList"></div>
            <br>
            AI<br>
            <br>
            <div id="aisList"></div>
            <br>
        </div>
        
        <div id="legend">
            <div class = "player">PLAYER</div>
            <div class = "start-field">START FIELD</div>
            <div class = "check-point">CHECK POINT</div>
            <div class = "eye">EYE</div>
            <div class = "hole">HOLE</div>
            <div class = "river-field">RIVER FIELD</div>
            <div class = "wall">WALL</div>
            <div class = "lembas-field">LEMBAS FIELD</div>
            <div class = "eagle-field">EAGLE FIELD</div>
        </div>
    
    </div>
    
    <div id="right">
    
        <div id="character">
            <div class = "character"></div>
            <div class = "character"></div>
        </div>
        
        <div id="confirm_character_choice">CONFIRM CHARACTER CHOICE</div>
        
        <div id="cards">
            <div class = "card"></div>
            <div class = "card"></div>
            <div class = "card"></div>
            <div class = "card"></div>
            <div class = "card"></div>
            <div class = "card"></div>
            <div class = "card"></div>
            <div class = "card"></div>
            <div class = "card"></div>
        </div>
        
        <div id="cards_choice">
            <div class = "card"></div>
            <div class = "card"></div>
            <div class = "card"></div>
            <div class = "card"></div>
            <div class = "card"></div>
        </div>
        
        <div id="confirm_card_choice">CONFIRM CARD CHOICE</div>
    
    </div>
    
<script>

Direction =
{
"NORTH" : "NORTH",
"EAST" : "EAST",
"SOUTH" : "SOUTH",
"WEST" : "WEST"
}

Role =
{
"PLAYER" : "PLAYER",
"SPECTATOR" : "SPECTATOR",
"AI" : "AI"

}

Card =
{
"MOVE_3" : "MOVE_3",
"MOVE_2" : "MOVE_2",
"MOVE_1" : "MOVE_1",
"MOVE_BACK" : "MOVE_BACK",
"U_TURN" : "U_TURN",
"RIGHT_TURN" : "RIGHT_TURN",
"LEFT_TURN" : "LEFT_TURN",
"AGAIN" : "AGAIN",
"LEMBAS" : "LEMBAS",
"EMPTY" : "EMPTY"
}

Character =
{
"FRODO" : "FRODO",
"SAM" : "SAM",
"LEGOLAS" : "LEGOLAS",
"GIMLI" : "GIMLI",
"GANDALF" : "GANDALF",
"ARAGORN" : "ARAGORN",
"GOLLUM" : "GOLLUM",
"GALADRIEL" : "GALADRIEL",
"BOROMIR" : "BOROMIR",
"BAUMBART" : "BAUMBART",
"MERRY" : "MERRY",
"PIPPIN" : "PIPPIN",
"ARWEN" : "ARWEN"
}

Message =
{
"ERROR" : "ERROR",                          // SERVER -> CLIENT
"INVALID_MESSAGE" : "INVALID_MESSAGE",      // SERVER -> CLIENT
"PARTICIPANTS_INFO" : "PARTICIPANTS_INFO",  // SERVER -> CLIENT
"HELLO_SERVER" : "HELLO_SERVER",            // CLIENT -> SERVER
"HELLO_CLIENT" : "HELLO_CLIENT",            // SERVER -> CLIENT
"GOODBYE_SERVER" : "GOODBYE_SERVER",        // CLIENT -> SERVER
"PLAYER_READY" : "PLAYER_READY",            // CLIENT -> SERVER
"GAME_START" : "GAME_START",                // SERVER -> CLIENT
"GAME_END" : "GAME_END",                    // SERVER -> CLIENT
"RECONNECT" : "RECONNECT",                  // SERVER -> CLIENT
"CHARACTER_OFFER" : "CHARACTER_OFFER",      // SERVER -> CLIENT
"CHARACTER_CHOICE" : "CHARACTER_CHOICE",    // CLIENT -> SERVER
"CARD_OFFER" : "CARD_OFFER",                // SERVER -> CLIENT
"CARD_CHOICE" : "CARD_CHOICE",              // CLIENT -> SERVER
"ROUND_START" : "ROUND_START",              // SERVER -> CLIENT
"CARD_EVENT" : "CARD_EVENT",                // SERVER -> CLIENT
"SHOT_EVENT" : "SHOT_EVENT",                // SERVER -> CLIENT
"RIVER_EVENT" : "RIVER_EVENT",              // SERVER -> CLIENT
"EAGLE_EVENT" : "EAGLE_EVENT",              // SERVER -> CLIENT
"GAME_STATE" : "GAME_STATE",                // SERVER -> CLIENT
"PAUSE_REQUEST" : "PAUSE_REQUEST",          // CLIENT -> SERVER
"PAUSED" : "PAUSED"                         // SERVER -> CLIENT
}

</script>
<script>

let token = null;
let myPlayerName = "Nudel";

let card_offer = [];
let card_choice = [];
let character_offer = [];
let selected_character = null;

connectButton.addEventListener("click", connectToServer);

let connection;
let connected = false;
let boardConfig
let gameConfig;

function connectToServer()
{
    if(!connected)
    {
        let ip = serverIpInput.value;
        let port = serverPortInput.value;
        let adress = `ws://${ip}:${port}`
        connection = new WebSocket(adress);
        connection.addEventListener("message", onMessage);
        connection.addEventListener("open", onConnected);
        connection.addEventListener("error", onError);
        connection.addEventListener("close",onClosed);

        connectButton.innerHTML = "CONNECTING"

    }
    else
    {
        onDisconnected();
    }
}

function onClosed()
{
    onDisconnected();
}

function onError()
{

}

function onConnected()
{
    connected = true;
    connectButton.innerHTML = "DISCONNECT";
}

function onDisconnected()
{
    connected = false;
    connectButton.innerHTML = "CONNECT";
    connection.close();
}

function onMessage(event)
{
    console.log(event);

    try
    {
        json = JSON.parse(event.data);
    }
    catch(error)
    {
        console.log(error);
        return
    }

    msg = json.message;
    data = json.data;

    switch (msg)
    {
        case Message.HELLO_CLIENT:
        
            token = data.reconnectToken;
            boardConfig = data.boardConfig;
            UpdateBoard(boardConfig);
            gameConfig = data.gameConfig;
            
            UpdateBoard(boardConfig);
            break;
            
        case Message.GAME_START:
        
            console.log("game was started");
            
            break;
            
        case Message.CHARACTER_OFFER:
        
            chars = data.characters;
            
            character_offer = chars;
            selected_character = null;
            
            DisplayCharacterOffer(chars);
            
            break;
            
        case Message.CARD_OFFER:
        
            cards = data.cards;
            
            card_offer = cards;
            card_choice = [];
            
            DisplayCardOffer(card_offer);
            DisplayCardChoice(card_choice);
            
            break;
            
        case Message.ROUND_START:
        
            roundstarted = true;
            playerstates = data.playerstates;
            break;
            
        case Message.CARD_EVENT:
        
            playerName = data.playerName;
            playerStates = data.playerStates
            card = data.card;
            
            for(let ps of playerStates)
            {
                UpdatePlayer(ps);
            }
            
            boardStates = data.boardStates;
            
            for(let bs of boardStates)
            {
                for (let e in bs)
                {
                    boardConfig[e] = bs[e];
                }
                UpdateBoard(boardConfig);
            }
            
            break;
            
        case Message.SHOT_EVENT:
        
            shooterName = data.shooterName;
            targetName = data.targetName;
            playerStates = data.playerStates;
            
            UpdatePlayer(playerStates);
            
            break;
            
        case Message.RIVER_EVENT:
        
            playerName = data.playerName;
            playerStates = data.playerStates;
            boardStates = data.boardStates;
            
            for(ps of playerStates)
            {
                UpdatePlayer(ps);
            }
            
            for(let bs of boardStates)
            {
                for (let e in bs)
                {
                    boardConfig[e] = bs[e];
                }
                UpdateBoard(boardConfig);
            }

            break;
            
        case Message.EAGLE_EVENT:
        
            playerName = data.playerName;
            playerStates = data.playerStates;
            
            UpdatePlayer(playerStates);
            
            break;
            
        case Message.GAME_STATE:
        
            playerStates = data.playerStates;
            boardStates = data.boardState;
            let currentRound = data.currentRound;
            
            for (let e in boardStates)
            {
                boardConfig[e] = boardStates[e];
            }
            
            UpdateBoard(boardConfig);
            UpdatePlayer(playerStates);
            UpdateRound(currentRound);
            
            break;
            
        case Message.GAME_END:
        
            playerStates = data.playerStates;
            winner = data.winner;
            additional = data.additional;
            
            UpdatePlayer(playerStates);
            
            console.log("game has ended");
            
            break;
            
        case Message.PAUSED:
        
            playerName = data.playerName;
            paused = data.paused;
            
            break;
            
        case Message.PARTICIPANTS_INFO:
        
            UpdateParticipants(data);
            
            break;
        
        case Message.INVALID_MESSAGE:
        
            invalidMessage = data.invalidMessage;
            
            break;
        
        case Message.ERROR:
        
            code = data.errorCode;
            reason = data.reason;
            
            switch (code)
            {
                case 0:
                    console.log("0 : Allgemeiner Fehlercode (Global)");
                    break;
                case 1:
                    console.log("1 : Nicht m√∂glich zu Verbinden (Global)");
                    break;
                case 2:
                    console.log("2 : Name ist bereits vergeben (Login)");
                    break;
                case 3:
                    console.log("3 : Name ist zu lang (Login)");
                    break;
                case 4:
                    console.log("4 : Partie hat bereits angefangen (Login)");
                    break;
                case 5:
                    console.log("5 : Die maximale Anzahl an Spielern ist bereits im Spiel (Login)");
                    break;
                case 6:
                    console.log("6: keine valide Kartenauswahl (Ingame)");
                    break;
                case 7:
                    console.log("7 : keine valide Charakterauswahl (Ingame)");
                    break;
                case 8:
                    console.log("8 : Kartenauswahltimeout (Ingame)");
                    break;
                case 9:
                    console.log("9 : Charakterauswahltimeout (Ingame)");
                    break;
                case 10:
                    console.log("10: Partie ist pausiert (Ingame, Pause)");
                    break;
                default:
                    console.log("unknown error code");
                
            }
            break;
        
        default:
        
            console.log("unknown message type : " + msg);

    }
}

function SendMessage(message)
{
    if(connected)
    {
        let json = JSON.stringify(message);
        connection.send(json);
        return true;
    }
    return false;
}

card_offer_buttons = document.body.querySelectorAll("#cards .card");
card_choice_buttons = document.body.querySelectorAll("#cards_choice .card");

character_choice_buttons = document.body.querySelectorAll("#character .character");

for(let i = 0; i < card_offer_buttons.length; i++)
{
    card_offer_buttons[i].addEventListener("click",() => {AddCard(i);});
}

for(let i = 0; i < card_choice_buttons.length; i++)
{
    card_choice_buttons[i].addEventListener("click",() => {RemoveCard(i)});
}

for(let i = 0; i < character_choice_buttons.length; i++)
{
    character_choice_buttons[i].addEventListener("click",() => {SelectCharacter(i)});
}

function AddCard(i)
{
    if(i < card_offer.length && card_choice.length < 5)
    {
        card_choice.push(card_offer[i]);
        card_offer.splice(i,1);
        DisplayCardOffer(card_offer);
        DisplayCardChoice(card_choice);
    }
}

function RemoveCard(i)
{
    if(i < card_choice.length)
    {
        card_offer.push(card_choice[i]);
        card_choice.splice(i,1);
        DisplayCardOffer(card_offer);
        DisplayCardChoice(card_choice);
    }
}

function SelectCharacter(i)
{
    selected_character = character_offer[i];
    for(ccb of character_choice_buttons)
    {
        ccb.classList.remove("active");
    }
    character_choice_buttons[i].classList.add("active");
    
}

confirm_card_choice.addEventListener("click",SendCardChoice);

function SendCardChoice()
{
    let msg = {}
    msg.message = Message.CARD_CHOICE;
    msg.data = {};
    msg.data.cards = [];

    for(let i = 0; i < 5; i++)
    {
        if(i < card_choice.length)
        {
            msg.data.cards.push(card_choice[i]);
        }
        else
        {
            msg.data.cards.push(Card.EMPTY);
        }
    }
    
    SendMessage(msg)
    
}

confirm_character_choice.addEventListener("click",SendCharacterChoice);

function SendCharacterChoice()
{

    if(selected_character != null)
    {
        let msg = {}
        msg.message = Message.CHARACTER_CHOICE;
        msg.data = {};
        msg.data.characterChoice = selected_character;
        SendMessage(msg)
    }
}

let c = document.createElement("canvas");
let s = 96;
document.body.appendChild(c);
let ctx = c.getContext("2d");

let isReady = false;

readyButton.addEventListener("click", () => {PlayerReady(!isReady)})

function PlayerReady(state)
{
    let msg = {};
    msg.message = Message.PLAYER_READY
    msg.data = {}
    msg.data.ready = state
    
    if(SendMessage(msg))
    {
        isReady = state;
    }
}

let canPause = true;
let paused = false;

pause.addEventListener("click",() => {RequestPause(!paused)});

function RequestPause(state)
{
    if(canPause)
    {
        let msg = {};
        msg.message = Message.PAUSE_REQUEST;
        msg.data = {};
        msg.data.pause = state;
        SendMessage(msg);
    }
}

exit.addEventListener("click", GoodByeServer)

function GoodByeServer()
{
    let msg = {}
    msg.message = Message.GOODBYE_SERVER;
    msg.data = {};
    SendMessage(msg);
    onDisconnected();
}

joinButton.addEventListener("click",Join);

function Join()
{
    let msg = {}
    msg.message = Message.HELLO_SERVER;
    msg.data = {}
    msg.data.role = roleDropdown.value;
    msg.data.name = playerNameInput.value;
    SendMessage(msg);
}

reconnect.addEventListener("click",Reconnect);

function Reconnect()
{
    
    if(token != null)
    {    
        let msg = {};
        msg.message = Message.RECONNECT;
        msg.data = {};
        msg.data.name = myPlayerName;
        msg.data.reconnectToken = token;
        
        SendMessage(msg);
    }
}

function UpdateParticipants(data)
{
    console.log("UPDATE PARTICIPANTS");

    let players = data.players;
    let spectators = data.spectators;
    let ais = data.ais;
    let readyPlayers = data.readyPlayers;
    
    console.log(players,spectators,ais,readyPlayers)
    
    playersList.innerHTML = "";
    spectatorsList.innerHTML = "";
    aisList.innerHTML = "";
    
    for(let player of players)
    {
        let part = document.createElement("div");
        playersList.appendChild(part);
        part.classList.add("participant");
        part.innerHTML = player;
        
        if(readyPlayers.includes(player))
        {
            part.classList.add("ready");
        }
    }

    
    for(let spectator of spectators)
    {
        let part = document.createElement("div");
        spectatorsList.appendChild(part);
        part.classList.add("participant");
        part.innerHTML = spectator;
    }    
    for(let ai of ais)
    {
        let part = document.createElement("div");
        aisList.appendChild(part);
        part.classList.add("participant");
        part.innerHTML = ai;
        
        if(readyPlayers.includes(ai))
        {
            part.classList.add("ready");
        }
    }
    
}

function UpdatePlayer(playerStates)
{
   for(let ps of playerStates)
    {
        let pos = ps.currentPosition;
        let dir = ps.direction;
        let char = ps.character;
        DrawPlayer(pos, dir);
    }   
}

function DisplayCardOffer(cards)
{
    let cardbox = document.body.querySelectorAll("#cards .card");
    
    for(let i = 0; i < cardbox.length; i++)
    {
        if(i < cards.length)
        {
            cardbox[i].innerHTML = cards[i];
        }
        else
        {
            cardbox[i].innerHTML = "";
        }
    }
}

function DisplayCardChoice(cards)
{
    let cardbox = document.body.querySelectorAll("#cards_choice .card");
    
    for(let i = 0; i < cardbox.length; i++)
    {
        if(i < cards.length)
        {
            cardbox[i].innerHTML = cards[i];
        }
        else
        {
            cardbox[i].innerHTML = "";
        }
    }
}

function DisplayCharacterOffer(character)
{
    let charbox = document.body.querySelectorAll("#character .character");
    
    for(let i = 0; i < charbox.length; i++)
    {
        if(i < character.length)
        {
            charbox[i].innerHTML = character[i];
        }
        else
        {
            charbox[i].innerHTML = "";
        }
    }
    
}

function UpdateRound(round)
{
    roundCounter.innerHTML = round;
}

function DrawEagleField(pos)
{
    if(pos !== undefined && pos[0] !== undefined && pos[1] !== undefined)
    {

        cx = s * pos[0] + s/2;
        cy = s * pos[1] + s/2;
        
        ctx.closePath()
        ctx.fillStyle = "#80400080";
        ctx.beginPath();
        ctx.arc(cx, cy, s/2, 0, 2 * Math.PI);
        ctx.closePath()
        ctx.fill();
        
        ctx.fillStyle = "#00000040";
        ctx.beginPath();
        ctx.arc(cx, cy, s/4, 0, 2 * Math.PI);
        ctx.fill();
    }
}

function DrawPlayer(pos,dir)
{
    ctx.fillStyle = "magenta";
    if(pos !== undefined && pos[0] !== undefined && pos[1] !== undefined)
    {
        cx = pos[0] * s + s/2;
        cy = pos[1] * s + s/2;
    
        ctx.beginPath();
        ctx.arc(cx, cy, s/3, 0, 2 * Math.PI);
        ctx.fill();
        if(dir !== undefined)
        {
            DrawArrow(pos[0],pos[1],dir);
        }
    }
}

function DrawLembas(pos)
{
    cx = s * pos[0] + s/2;
    cy = s * pos[1] + s/2;
    
    as = s/4;

    ctx.strokeStyle = "#aaaa40";
    ctx.fillStyle = "#eeee80";
    if(pos !== undefined && pos[0] !== undefined && pos[1] !== undefined)
    {
        
        ctx.beginPath();
        ctx.moveTo(cx - as, cy - as);
        ctx.lineTo(cx + as, cy - as);
        ctx.lineTo(cx + as, cy + as);
        ctx.lineTo(cx - as, cy + as);
        ctx.closePath();
        ctx.fill();
        //ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx - as, cy - as)
        ctx.lineTo(cx + as, cy + as);
        ctx.moveTo(cx + as, cy - as);
        ctx.lineTo(cx - as, cy + as);
        ctx.closePath();
        ctx.stroke();
    }
}

function UpdateBoard(bc)
{
    let h = bc.height;
    let w = bc.width;

    c.width = s * w;
    c.height = s * h;

    for(let x = 0; x < w; x++)
    {
        for(let y = 0; y < h; y++)
        {
            if(x % 2 == y % 2)
            {
                ctx.fillStyle = "#EEE";
            }
            else
            {
                ctx.fillStyle = "#CCC";
            }
            
            ctx.fillRect(x * s, y * s, s, s);
            
            ctx.fillStyle = "black";
            ctx.textAlign = "right";
            ctx.textBaseline = 'middle';
            ctx.fillText(`(${x}, ${y})`, x * s + s, y * s + s - 5);
        }
    }

    for(sf of bc.startFields)
    {
        pos = sf.position;
        dir = sf.direction;
        
        ctx.fillStyle = "#ffff0080";
        
        if(pos !== undefined && pos[0] !== undefined && pos[1] !== undefined)
        {
            ctx.fillRect(pos[0] * s, pos[1] * s, s, s);
            
            if(dir)
            {
                DrawArrow(pos[0], pos[1], dir);
            }
        }
    }

    for(cp of bc.checkPoints)
    {
        ctx.fillStyle = "#00ffff80";
        if(cp[0] !== undefined && cp[1] !== undefined)
        {
            //ctx.fillRect(cp[0] * s, cp[1] * s, s, s);
            ctx.beginPath();
            ctx.arc((0.5 + cp[0]) * s, (0.5 + cp[1]) * s, s/4, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    let ep = bc.eye.position;
    let ed = bc.eye.direction;

    ctx.fillStyle = "#ff800080";
    if(ep !== undefined && ep[0] !== undefined && ep[1] !== undefined)
    {
        //ctx.fillRect(ep[0] * s, ep[1] * s, s, s)
        ctx.beginPath();
        ctx.arc((0.5 + ep[0]) * s, (0.5 + ep[1]) * s, s/2, 0, 2 * Math.PI);
        ctx.fill();
        if(ed !== undefined)
        {
            DrawArrow(ep[0],ep[1],ed);
        }
    }

    for(h of bc.holes)
    {
        ctx.fillStyle = "#00000080";
        if(h[0] !== undefined && h[1] !== undefined)
        {
            ctx.fillRect(h[0] * s, h[1] * s, s, s);
        }
    }

    for(rf of bc.riverFields)
    {
        pos = rf.position;
        dir = rf.direction;
        
        ctx.fillStyle = "#0000ff80";
        
        if(pos !== undefined && pos[0] !== undefined && pos[1] !== undefined)
        {
            ctx.fillRect(pos[0] * s, pos[1] * s, s, s);
            
            if(dir)
            {
                DrawArrow(pos[0], pos[1], dir);
            }
        }
    }

    for(wall of bc.walls)
    {
        ctx.fillStyle = "#ff000080";
        
        let ax = wall[0][0]
        let ay = wall[0][1]
        let bx = wall[1][0]
        let by = wall[1][1]
        
        if(ax !== undefined && ay !== undefined && bx !== undefined && by !== undefined)
        {
            wt = s/4
        
            if(ax == bx && Math.abs(ay - by) == 1)
            {
                let x = ax;
                let y = ay > by ? ay : by;
                ctx.fillRect(x * s, y * s - (wt/2), s, wt);
            }
            else if(ay == ay && Math.abs(ax - bx) == 1)
            {
                let y = ay;
                let x = ax > bx ? ax : bx;
                ctx.fillRect(x * s - (wt/2), y * s, wt, s);
            }
        }
    }

    for(lf of bc.lembasFields)
    {
        pos = lf.position;
        amo = lf.amount;
        
        ctx.fillStyle = "#80ff0080";
        
        if(pos !== undefined && pos[0] !== undefined && pos[1] !== undefined)
        {
            ctx.fillRect(pos[0] * s, pos[1] * s, s, s);

            DrawLembas(pos);

            if(amo !== undefined)
            {
                    ctx.fillStyle = "#000000ff";
                    ctx.textAlign = "center";
                    ctx.textBaseline = 'middle';
                    ctx.font = "20px Arial";
                    ctx.fillText(amo, (0.5 + pos[0]) * s, (0.5 + pos[1]) * s);
            }
            
        }

    }

    for(ef of bc.eagleFields)
    {
    
        DrawEagleField(ef);
        /*
        ctx.fillStyle = "#80400080";
        
        if(ef[0] !== undefined && ef[1] !== undefined)
        {
            ctx.fillRect(ef[0] * s, ef[1] * s, s, s);
        }
        */
    }

}

function DrawArrow(x,y,d)
{
    cx = s * x + s/2;
    cy = s * y + s/2;
    
    as = s/8;
    
    ctx.fillStyle = "#00000020";
    ctx.strokeStyle = "#00000080";

    switch (d)
    {
        case Direction.NORTH:
        
            ctx.beginPath();
            ctx.moveTo(cx - as, cy + as);
            ctx.lineTo(cx, cy - as);
            ctx.lineTo(cx + as, cy + as);
            ctx.closePath();
            //ctx.stroke();
            ctx.fill();
            break;
        case Direction.EAST:
        
            ctx.beginPath();
            ctx.moveTo(cx - as, cy - as);
            ctx.lineTo(cx + as, cy);
            ctx.lineTo(cx - as, cy + as);
            ctx.closePath();
            //ctx.stroke();
            ctx.fill();
            break;
        case Direction.SOUTH:
        
            ctx.beginPath();
            ctx.moveTo(cx - as, cy - as);
            ctx.lineTo(cx, cy + as);
            ctx.lineTo(cx + as, cy - as);
            ctx.closePath();
            //ctx.stroke();
            ctx.fill();
            break;
        case Direction.WEST:
        
            ctx.beginPath();
            ctx.moveTo(cx + as, cy - as);
            ctx.lineTo(cx - as, cy);
            ctx.lineTo(cx + as, cy + as);
            ctx.closePath();
            //ctx.stroke();
            ctx.fill();
            break;
   
    }
    
}

</script>
</body>
</html>